
// Enhanced emoji set for 9-layer encryption - significantly expanded
const emojiSet = [
  // Faces and emotions (expanded)
  'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©',
  'üòò', 'üòó', '‚ò∫Ô∏è', 'üòö', 'üòô', 'ü•≤', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î',
  'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòå', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑',
  'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'ü•¥', 'üòµ', 'ü§Ø', 'ü§†', 'ü•≥', 'ü•∏', 'üòé', 'ü§ì', 'üßê',
  
  // Animals and nature (expanded)
  'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üêΩ', 'üê∏', 'üêµ',
  'üêí', 'üêî', 'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù',
  'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü¶ó', 'üï∑Ô∏è', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë',
  'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß',
  
  // Food and drink (expanded)
  'üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü´ê', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù',
  'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂Ô∏è', 'ü´ë', 'üåΩ', 'ü•ï', 'ü´í', 'üßÑ', 'üßÖ', 'ü•î', 'üç†', 'ü•ê',
  'ü•ñ', 'üçû', 'ü•®', 'ü•Ø', 'üßÄ', 'ü•ö', 'üç≥', 'üßà', 'ü•û', 'üßá', 'ü•ì', 'ü•©', 'üçó', 'üçñ', 'ü¶¥', 'üå≠',
  'üçî', 'üçü', 'üçï', 'üåÆ', 'üåØ', 'ü•ô', 'üßÜ', 'ü•ò', 'üçù', 'üçú', 'üç≤', 'üçõ', 'üç£', 'üç±', 'ü•ü', 'ü¶™',
  
  // Objects and symbols (expanded)
  '‚≠ê', 'üåü', '‚ú®', '‚ö°', 'üî•', 'üíØ', 'üí´', 'üåô', '‚òÄÔ∏è', 'üåà', '‚òî', '‚ùÑÔ∏è', '‚õÑ', 'üåä', 'üíé', 'üîÆ',
  'üí∞', 'üí¥', 'üíµ', 'üí∂', 'üí∑', 'üí∏', 'üí≥', 'üèÜ', 'ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üéñÔ∏è', 'üèµÔ∏è', 'üéóÔ∏è', 'üé´',
  'üé™', 'üé®', 'üé≠', 'üé™', 'üéº', 'üéµ', 'üé∂', 'üé§', 'üéß', 'üìª', 'üé∑', 'üé∏', 'üéπ', 'üé∫', 'üéª', 'ü™ï',
  'üîî', 'üîï', 'üì¢', 'üì£', 'üìØ', 'üîä', 'üîâ', 'üîà', 'üì±', 'üì≤', '‚òéÔ∏è', 'üìû', 'üìü', 'üì†', 'üîã', 'üîå',
  
  // Activities and sports (expanded)
  '‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç',
  'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõ∑', '‚õ∏Ô∏è', 'ü•å', 'üéø',
  '‚õ∑Ô∏è', 'üèÇ', 'ü™Ç', 'üèãÔ∏è', 'ü§º', 'ü§∏', '‚õπÔ∏è', 'ü§∫', 'üèá', 'üßò', 'üèÑ', 'üèä', 'üö¥', 'üöµ', 'üßó', 'ü§æ',
  
  // Transport and travel (expanded)
  'üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'üèçÔ∏è', 'üõµ',
  'üö≤', 'üõ¥', 'üõ∫', 'üöü', 'üö†', 'üö°', 'üöÇ', 'üöÉ', 'üöÑ', 'üöÖ', 'üöÜ', 'üöá', 'üöà', 'üöâ', 'üöä', 'üöù',
  'üöû', 'üöã', 'üöÉ', 'üöñ', 'üöò', 'üöç', 'üöî', 'üö®', 'üö•', 'üö¶', 'üõë', 'üöß', '‚öì', '‚õµ', 'üõ∂', 'üö§',
  
  // Hearts and symbols (expanded)
  'üíú', 'üíô', 'üíö', 'üíõ', 'üß°', '‚ù§Ô∏è', 'ü§ç', 'üñ§', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ',
  'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà',
  '‚ôâ', '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë', '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥', 'üì≥'
];

// Fixed hex-to-emoji conversion for 9-layer security
export const encodeWithEmojis = (text: string): string => {
  console.log('üöÄ 9-Layer Emoji encoding initiated for:', text.substring(0, 20) + '...');
  
  try {
    if (!text || text.trim() === '') {
      return 'Empty text provided';
    }

    // Ensure we're working with valid hex string
    const cleanHex = text.replace(/[^0-9a-fA-F]/g, '');
    if (cleanHex.length % 2 !== 0) {
      return 'Invalid hex format - odd length';
    }

    const hexPairs = cleanHex.match(/.{2}/g);
    if (!hexPairs) {
      return 'Invalid hex format';
    }
    
    let encoded = '';
    for (const hexPair of hexPairs) {
      const byteValue = parseInt(hexPair, 16);
      if (isNaN(byteValue)) {
        return 'Invalid hex characters detected';
      }
      const emojiIndex = byteValue % emojiSet.length;
      encoded += emojiSet[emojiIndex];
    }
    
    console.log('‚úÖ 9-Layer emoji encoding complete:', encoded.substring(0, 10) + '...');
    return encoded;
  } catch (error) {
    console.error('‚ùå 9-Layer emoji encoding failed:', error);
    return 'Encoding failed: ' + (error instanceof Error ? error.message : 'Unknown error');
  }
};

export const decodeFromEmojis = (emojiText: string): string => {
  console.log('üîì 9-Layer Emoji decoding initiated for:', emojiText.substring(0, 10) + '...');
  
  try {
    if (!emojiText || emojiText.trim() === '') {
      return 'Empty emoji message';
    }

    const emojiArray = Array.from(emojiText.trim());
    let hexString = '';
    
    // Convert each emoji back to hex
    for (const emoji of emojiArray) {
      const emojiIndex = emojiSet.indexOf(emoji);
      
      if (emojiIndex === -1) {
        console.error('‚ùå Unknown emoji detected:', emoji);
        return 'Invalid emoji in message - corrupted data';
      }
      
      // Convert emoji index back to hex (pad with 0 if needed)
      const hexValue = emojiIndex.toString(16).padStart(2, '0');
      hexString += hexValue;
    }
    
    console.log('‚úÖ 9-Layer emoji decoding complete');
    return hexString;
  } catch (error) {
    console.error('‚ùå 9-Layer emoji decoding failed:', error);
    return 'Invalid emoji message or corruption detected';
  }
};

// Enhanced 9-layer password encoding with better error handling
export const applyPasswordEncoding = (text: string, key: string): string => {
  console.log('üîê 9-Layer password encoding initiated');
  
  try {
    if (!text || !key) {
      return 'Missing text or key';
    }

    // Layer 9: Anti-tamper header with timestamp
    const timestamp = Date.now().toString(36);
    const enhancedText = `${timestamp}:${text}:${timestamp}`;
    
    // Convert to base64 first for safe processing
    const base64Text = btoa(unescape(encodeURIComponent(enhancedText)));
    
    let currentData = base64Text;
    const keyArray = Array.from(key);
    
    // 9-layer encoding with multiple rounds
    for (let round = 0; round < 9; round++) {
      let encoded = '';
      const textArray = Array.from(currentData);
      
      for (let i = 0; i < textArray.length; i++) {
        const textChar = textArray[i].charCodeAt(0);
        const keyChar = keyArray[i % keyArray.length].charCodeAt(0);
        const saltValue = (i + round + 1) * 17; // Dynamic salt
        const encodedValue = (textChar + keyChar + saltValue) % 256; // Keep within byte range
        const encodedChar = encodedValue.toString(16).padStart(2, '0'); // Convert to hex
        encoded += encodedChar;
      }
      
      currentData = encoded;
    }
    
    console.log('‚úÖ 9-Layer password encoding complete');
    return currentData;
  } catch (error) {
    console.error('‚ùå 9-Layer password encoding failed:', error);
    return 'Password encoding failed: ' + (error instanceof Error ? error.message : 'Unknown error');
  }
};

// Enhanced 9-layer password decoding with better error handling
export const applyPasswordDecoding = (encodedText: string, key: string): string => {
  console.log('üîì 9-Layer password decoding initiated');
  
  try {
    if (!encodedText || encodedText.trim() === '' || !key) {
      return 'Empty encoded message or missing key';
    }

    // Validate hex format
    const cleanHex = encodedText.replace(/[^0-9a-fA-F]/g, '');
    if (!/^[0-9a-fA-F]+$/.test(cleanHex) || cleanHex.length % 2 !== 0) {
      return 'Invalid hex format';
    }

    let currentData = cleanHex;
    const keyArray = Array.from(key);
    
    // Reverse the 9-layer encoding process
    for (let round = 8; round >= 0; round--) {
      const hexPairs = currentData.match(/.{2}/g);
      if (!hexPairs) {
        return 'Invalid hex data in round ' + (8 - round + 1);
      }
      
      let original = '';
      for (let i = 0; i < hexPairs.length; i++) {
        const encodedChar = parseInt(hexPairs[i], 16);
        if (isNaN(encodedChar)) {
          return 'Invalid hex character in round ' + (8 - round + 1);
        }
        
        const keyChar = keyArray[i % keyArray.length].charCodeAt(0);
        const saltValue = (i + round + 1) * 17;
        const originalValue = (encodedChar - keyChar - saltValue + 256) % 256;
        original += String.fromCharCode(originalValue);
      }
      
      currentData = original;
    }
    
    // Decode from base64
    try {
      const decodedBase64 = decodeURIComponent(escape(atob(currentData)));
      
      // Layer 9: Verify anti-tamper header
      const parts = decodedBase64.split(':');
      if (parts.length === 3 && parts[0] === parts[2]) {
        console.log('‚úÖ 9-Layer password decoding complete with verification');
        return parts[1]; // Return the original message
      } else {
        console.error('‚ùå Anti-tamper verification failed');
        return 'Message integrity verification failed';
      }
    } catch (decodeError) {
      console.error('‚ùå Base64 decode failed:', decodeError);
      return 'Invalid message format or wrong password';
    }
  } catch (error) {
    console.error('‚ùå 9-Layer password decoding failed:', error);
    return 'Invalid message or wrong password: ' + (error instanceof Error ? error.message : 'Unknown error');
  }
};

// Main 9-layer encoding function
export const encodeMessage = (text: string, key: string, method: string): string => {
  if (!text || !key) return 'Missing text or password';
  
  console.log('üöÄ Initiating 9-Layer encryption system');
  
  try {
    // Apply password encoding first
    const passwordEncoded = applyPasswordEncoding(text, key);
    if (passwordEncoded.includes('failed') || passwordEncoded.includes('Missing')) {
      return passwordEncoded;
    }
    
    if (method === 'emoji') {
      // Convert hex to emojis
      return encodeWithEmojis(passwordEncoded);
    }
    
    // Text method: return hex directly
    return passwordEncoded;
  } catch (error) {
    console.error('‚ùå 9-Layer encoding failed:', error);
    return 'Encoding failed: ' + (error instanceof Error ? error.message : 'Unknown error');
  }
};

// Main 9-layer decoding function
export const decodeMessage = (encodedText: string, key: string, method: string): string => {
  if (!encodedText || !key) return 'Missing encoded text or password';
  
  console.log('üîì Initiating 9-Layer decryption system');
  
  try {
    let hexData = encodedText.trim();
    
    if (method === 'emoji') {
      // Decode from emojis to hex first
      hexData = decodeFromEmojis(encodedText);
      if (hexData.includes('Invalid') || hexData.includes('failed') || hexData.includes('Empty') || hexData.includes('corrupted')) {
        return hexData;
      }
    }
    
    // Apply password decoding
    const result = applyPasswordDecoding(hexData, key);
    return result;
  } catch (error) {
    console.error('‚ùå 9-Layer decoding failed:', error);
    return 'Invalid message or wrong password: ' + (error instanceof Error ? error.message : 'Unknown error');
  }
};
